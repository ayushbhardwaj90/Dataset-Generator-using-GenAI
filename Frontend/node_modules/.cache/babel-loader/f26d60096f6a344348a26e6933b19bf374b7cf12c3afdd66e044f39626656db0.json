{"ast":null,"code":"// src/index.ts\nimport equal2 from \"@gilbarbara/deep-equal\";\nimport is2 from \"is-lite\";\n\n// src/helpers.ts\nimport equal from \"@gilbarbara/deep-equal\";\nimport is from \"is-lite\";\nfunction canHaveLength() {\n  for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n    arguments_[_key] = arguments[_key];\n  }\n  return arguments_.every(d => is.string(d) || is.array(d) || is.plainObject(d));\n}\nfunction checkEquality(left, right, value) {\n  if (!isSameType(left, right)) {\n    return false;\n  }\n  if ([left, right].every(is.array)) {\n    return !left.some(hasValue(value)) && right.some(hasValue(value));\n  }\n  if ([left, right].every(is.plainObject)) {\n    return !Object.entries(left).some(hasEntry(value)) && Object.entries(right).some(hasEntry(value));\n  }\n  return right === value;\n}\nfunction compareNumbers(previousData, data, options) {\n  const {\n    actual,\n    key,\n    previous,\n    type\n  } = options;\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n  let changed = [left, right].every(is.number) && (type === \"increased\" ? left < right : left > right);\n  if (!is.undefined(actual)) {\n    changed = changed && right === actual;\n  }\n  if (!is.undefined(previous)) {\n    changed = changed && left === previous;\n  }\n  return changed;\n}\nfunction compareValues(previousData, data, options) {\n  const {\n    key,\n    type,\n    value\n  } = options;\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n  const primary = type === \"added\" ? left : right;\n  const secondary = type === \"added\" ? right : left;\n  if (!is.nullOrUndefined(value)) {\n    if (is.defined(primary)) {\n      if (is.array(primary) || is.plainObject(primary)) {\n        return checkEquality(primary, secondary, value);\n      }\n    } else {\n      return equal(secondary, value);\n    }\n    return false;\n  }\n  if ([left, right].every(is.array)) {\n    return !secondary.every(isEqualPredicate(primary));\n  }\n  if ([left, right].every(is.plainObject)) {\n    return hasExtraKeys(Object.keys(primary), Object.keys(secondary));\n  }\n  return ![left, right].every(d => is.primitive(d) && is.defined(d)) && (type === \"added\" ? !is.defined(left) && is.defined(right) : is.defined(left) && !is.defined(right));\n}\nfunction getIterables(previousData, data) {\n  let {\n    key\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let left = nested(previousData, key);\n  let right = nested(data, key);\n  if (!isSameType(left, right)) {\n    throw new TypeError(\"Inputs have different types\");\n  }\n  if (!canHaveLength(left, right)) {\n    throw new TypeError(\"Inputs don't have length\");\n  }\n  if ([left, right].every(is.plainObject)) {\n    left = Object.keys(left);\n    right = Object.keys(right);\n  }\n  return [left, right];\n}\nfunction hasEntry(input) {\n  return _ref => {\n    let [key, value] = _ref;\n    if (is.array(input)) {\n      return equal(input, value) || input.some(d => equal(d, value) || is.array(value) && isEqualPredicate(value)(d));\n    }\n    if (is.plainObject(input) && input[key]) {\n      return !!input[key] && equal(input[key], value);\n    }\n    return equal(input, value);\n  };\n}\nfunction hasExtraKeys(left, right) {\n  return right.some(d => !left.includes(d));\n}\nfunction hasValue(input) {\n  return value => {\n    if (is.array(input)) {\n      return input.some(d => equal(d, value) || is.array(value) && isEqualPredicate(value)(d));\n    }\n    return equal(input, value);\n  };\n}\nfunction includesOrEqualsTo(previousValue, value) {\n  return is.array(previousValue) ? previousValue.some(d => equal(d, value)) : equal(previousValue, value);\n}\nfunction isEqualPredicate(data) {\n  return value => data.some(d => equal(d, value));\n}\nfunction isSameType() {\n  for (var _len2 = arguments.length, arguments_ = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    arguments_[_key2] = arguments[_key2];\n  }\n  return arguments_.every(is.array) || arguments_.every(is.number) || arguments_.every(is.plainObject) || arguments_.every(is.string);\n}\nfunction nested(data, property) {\n  if (is.plainObject(data) || is.array(data)) {\n    if (is.string(property)) {\n      const props = property.split(\".\");\n      return props.reduce((acc, d) => acc && acc[d], data);\n    }\n    if (is.number(property)) {\n      return data[property];\n    }\n    return data;\n  }\n  return data;\n}\n\n// src/index.ts\nfunction treeChanges(previousData, data) {\n  if ([previousData, data].some(is2.nullOrUndefined)) {\n    throw new Error(\"Missing required parameters\");\n  }\n  if (![previousData, data].every(d => is2.plainObject(d) || is2.array(d))) {\n    throw new Error(\"Expected plain objects or array\");\n  }\n  const added = (key, value) => {\n    try {\n      return compareValues(previousData, data, {\n        key,\n        type: \"added\",\n        value\n      });\n    } catch (_unused) {\n      return false;\n    }\n  };\n  const changed = (key, actual, previous) => {\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is2.defined(actual);\n      const hasPrevious = is2.defined(previous);\n      if (hasActual || hasPrevious) {\n        const leftComparator = hasPrevious ? includesOrEqualsTo(previous, left) : !includesOrEqualsTo(actual, left);\n        const rightComparator = includesOrEqualsTo(actual, right);\n        return leftComparator && rightComparator;\n      }\n      if ([left, right].every(is2.array) || [left, right].every(is2.plainObject)) {\n        return !equal2(left, right);\n      }\n      return left !== right;\n    } catch (_unused2) {\n      return false;\n    }\n  };\n  const changedFrom = (key, previous, actual) => {\n    if (!is2.defined(key)) {\n      return false;\n    }\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is2.defined(actual);\n      return includesOrEqualsTo(previous, left) && (hasActual ? includesOrEqualsTo(actual, right) : !hasActual);\n    } catch (_unused3) {\n      return false;\n    }\n  };\n  const decreased = (key, actual, previous) => {\n    if (!is2.defined(key)) {\n      return false;\n    }\n    try {\n      return compareNumbers(previousData, data, {\n        key,\n        actual,\n        previous,\n        type: \"decreased\"\n      });\n    } catch (_unused4) {\n      return false;\n    }\n  };\n  const emptied = key => {\n    try {\n      const [left, right] = getIterables(previousData, data, {\n        key\n      });\n      return !!left.length && !right.length;\n    } catch (_unused5) {\n      return false;\n    }\n  };\n  const filled = key => {\n    try {\n      const [left, right] = getIterables(previousData, data, {\n        key\n      });\n      return !left.length && !!right.length;\n    } catch (_unused6) {\n      return false;\n    }\n  };\n  const increased = (key, actual, previous) => {\n    if (!is2.defined(key)) {\n      return false;\n    }\n    try {\n      return compareNumbers(previousData, data, {\n        key,\n        actual,\n        previous,\n        type: \"increased\"\n      });\n    } catch (_unused7) {\n      return false;\n    }\n  };\n  const removed = (key, value) => {\n    try {\n      return compareValues(previousData, data, {\n        key,\n        type: \"removed\",\n        value\n      });\n    } catch (_unused8) {\n      return false;\n    }\n  };\n  return {\n    added,\n    changed,\n    changedFrom,\n    decreased,\n    emptied,\n    filled,\n    increased,\n    removed\n  };\n}\nexport { treeChanges as default };","map":{"version":3,"names":["equal2","is2","equal","is","canHaveLength","_len","arguments","length","arguments_","Array","_key","every","d","string","array","plainObject","checkEquality","left","right","value","isSameType","some","hasValue","Object","entries","hasEntry","compareNumbers","previousData","data","options","actual","key","previous","type","nested","changed","number","undefined","compareValues","primary","secondary","nullOrUndefined","defined","isEqualPredicate","hasExtraKeys","keys","primitive","getIterables","TypeError","input","_ref","includes","includesOrEqualsTo","previousValue","_len2","_key2","property","props","split","reduce","acc","treeChanges","Error","added","_unused","hasActual","hasPrevious","leftComparator","rightComparator","_unused2","changedFrom","_unused3","decreased","_unused4","emptied","_unused5","filled","_unused6","increased","_unused7","removed","_unused8"],"sources":["/workspace/Frontend/node_modules/tree-changes/src/index.ts","/workspace/Frontend/node_modules/tree-changes/src/helpers.ts"],"sourcesContent":["import equal from '@gilbarbara/deep-equal';\nimport is from 'is-lite';\n\nimport { compareNumbers, compareValues, getIterables, includesOrEqualsTo, nested } from './helpers';\nimport { Data, KeyType, TreeChanges, Value } from './types';\n\nexport default function treeChanges<P extends Data, D extends Data, K = KeyType<P, D>>(\n  previousData: P,\n  data: D,\n): TreeChanges<K> {\n  if ([previousData, data].some(is.nullOrUndefined)) {\n    throw new Error('Missing required parameters');\n  }\n\n  if (![previousData, data].every(d => is.plainObject(d) || is.array(d))) {\n    throw new Error('Expected plain objects or array');\n  }\n\n  const added = (key?: K, value?: Value): boolean => {\n    try {\n      return compareValues<K>(previousData, data, { key, type: 'added', value });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const changed = (key?: K | string, actual?: Value, previous?: Value): boolean => {\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is.defined(actual);\n      const hasPrevious = is.defined(previous);\n\n      if (hasActual || hasPrevious) {\n        const leftComparator = hasPrevious\n          ? includesOrEqualsTo(previous, left)\n          : !includesOrEqualsTo(actual, left);\n        const rightComparator = includesOrEqualsTo(actual, right);\n\n        return leftComparator && rightComparator;\n      }\n\n      if ([left, right].every(is.array) || [left, right].every(is.plainObject)) {\n        return !equal(left, right);\n      }\n\n      return left !== right;\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const changedFrom = (key: K | string, previous: Value, actual?: Value): boolean => {\n    if (!is.defined(key)) {\n      return false;\n    }\n\n    try {\n      const left = nested(previousData, key);\n      const right = nested(data, key);\n      const hasActual = is.defined(actual);\n\n      return (\n        includesOrEqualsTo(previous, left) &&\n        (hasActual ? includesOrEqualsTo(actual, right) : !hasActual)\n      );\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const decreased = (key: K, actual?: Value, previous?: Value): boolean => {\n    if (!is.defined(key)) {\n      return false;\n    }\n\n    try {\n      return compareNumbers<K>(previousData, data, { key, actual, previous, type: 'decreased' });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const emptied = (key?: K): boolean => {\n    try {\n      const [left, right] = getIterables(previousData, data, { key });\n\n      return !!left.length && !right.length;\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const filled = (key?: K): boolean => {\n    try {\n      const [left, right] = getIterables(previousData, data, { key });\n\n      return !left.length && !!right.length;\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const increased = (key: K, actual?: Value, previous?: Value): boolean => {\n    if (!is.defined(key)) {\n      return false;\n    }\n\n    try {\n      return compareNumbers<K>(previousData, data, { key, actual, previous, type: 'increased' });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  const removed = (key?: K, value?: Value): boolean => {\n    try {\n      return compareValues<K>(previousData, data, { key, type: 'removed', value });\n    } catch {\n      /* istanbul ignore next */\n      return false;\n    }\n  };\n\n  return { added, changed, changedFrom, decreased, emptied, filled, increased, removed };\n}\n\nexport type { Data, KeyType, TreeChanges, Value } from './types';\n","import equal from '@gilbarbara/deep-equal';\nimport is from 'is-lite';\n\nimport { CompareValuesOptions, Data, Key, Options, ValidTypes, Value } from './types';\n\nexport function canHaveLength(...arguments_: any): boolean {\n  return arguments_.every((d: unknown) => is.string(d) || is.array(d) || is.plainObject(d));\n}\n\nexport function checkEquality(left: Data, right: Data, value: Value) {\n  if (!isSameType(left, right)) {\n    return false;\n  }\n\n  if ([left, right].every(is.array)) {\n    return !left.some(hasValue(value)) && right.some(hasValue(value));\n  }\n\n  /* istanbul ignore else */\n  if ([left, right].every(is.plainObject)) {\n    return (\n      !Object.entries(left).some(hasEntry(value)) && Object.entries(right).some(hasEntry(value))\n    );\n  }\n\n  return right === value;\n}\n\nexport function compareNumbers<K = Key>(\n  previousData: Data,\n  data: Data,\n  options: Options<K>,\n): boolean {\n  const { actual, key, previous, type } = options;\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n\n  let changed =\n    [left, right].every(is.number) && (type === 'increased' ? left < right : left > right);\n\n  if (!is.undefined(actual)) {\n    changed = changed && right === actual;\n  }\n\n  if (!is.undefined(previous)) {\n    changed = changed && left === previous;\n  }\n\n  return changed;\n}\n\nexport function compareValues<K = Key>(\n  previousData: Data,\n  data: Data,\n  options: CompareValuesOptions<K>,\n) {\n  const { key, type, value } = options;\n\n  const left = nested(previousData, key);\n  const right = nested(data, key);\n  const primary = type === 'added' ? left : right;\n  const secondary = type === 'added' ? right : left;\n\n  if (!is.nullOrUndefined(value)) {\n    if (is.defined(primary)) {\n      // check if nested data matches\n      if (is.array(primary) || is.plainObject(primary)) {\n        return checkEquality(primary, secondary, value);\n      }\n    } else {\n      return equal(secondary, value);\n    }\n\n    return false;\n  }\n\n  if ([left, right].every(is.array)) {\n    return !secondary.every(isEqualPredicate(primary));\n  }\n\n  if ([left, right].every(is.plainObject)) {\n    return hasExtraKeys(Object.keys(primary), Object.keys(secondary));\n  }\n\n  return (\n    ![left, right].every(d => is.primitive(d) && is.defined(d)) &&\n    (type === 'added'\n      ? !is.defined(left) && is.defined(right)\n      : is.defined(left) && !is.defined(right))\n  );\n}\n\nexport function getIterables<K = Key>(previousData: Data, data: Data, { key }: Options<K> = {}) {\n  let left = nested(previousData, key);\n  let right = nested(data, key);\n\n  if (!isSameType(left, right)) {\n    throw new TypeError('Inputs have different types');\n  }\n\n  if (!canHaveLength(left, right)) {\n    throw new TypeError(\"Inputs don't have length\");\n  }\n\n  if ([left, right].every(is.plainObject)) {\n    left = Object.keys(left);\n    right = Object.keys(right);\n  }\n\n  return [left, right];\n}\n\nexport function hasEntry(input: Value) {\n  return ([key, value]: [string, Value]) => {\n    if (is.array(input)) {\n      return (\n        equal(input, value) ||\n        input.some(d => equal(d, value) || (is.array(value) && isEqualPredicate(value)(d)))\n      );\n    }\n\n    /* istanbul ignore else */\n    if (is.plainObject(input) && input[key]) {\n      return !!input[key] && equal(input[key], value);\n    }\n\n    return equal(input, value);\n  };\n}\n\nexport function hasExtraKeys(left: string[], right: string[]): boolean {\n  return right.some(d => !left.includes(d));\n}\n\nexport function hasValue(input: Value) {\n  return (value: Value) => {\n    if (is.array(input)) {\n      return input.some(d => equal(d, value) || (is.array(value) && isEqualPredicate(value)(d)));\n    }\n\n    return equal(input, value);\n  };\n}\n\nexport function includesOrEqualsTo<T>(previousValue: T | T[], value: T): boolean {\n  return is.array(previousValue)\n    ? previousValue.some(d => equal(d, value))\n    : equal(previousValue, value);\n}\n\nexport function isEqualPredicate(data: unknown[]) {\n  return (value: unknown) => data.some(d => equal(d, value));\n}\n\nexport function isSameType(...arguments_: ValidTypes[]): boolean {\n  return (\n    arguments_.every(is.array) ||\n    arguments_.every(is.number) ||\n    arguments_.every(is.plainObject) ||\n    arguments_.every(is.string)\n  );\n}\n\nexport function nested<T extends Data, K = Key>(data: T, property?: K) {\n  /* istanbul ignore else */\n  if (is.plainObject(data) || is.array(data)) {\n    /* istanbul ignore else */\n    if (is.string(property)) {\n      const props: Array<any> = property.split('.');\n\n      return props.reduce((acc, d) => acc && acc[d], data);\n    }\n\n    /* istanbul ignore else */\n    if (is.number(property)) {\n      return data[property];\n    }\n\n    return data;\n  }\n\n  return data;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}